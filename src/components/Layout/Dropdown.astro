---
interface Props {
  inlineMenu?: boolean;
  label?: string;
}

// generate unique ids for each component so that we can connect the button to the dropdown without requiring consumer to provide an id
// https://github.com/MicroWebStacks/astro-examples/blob/c278c3fc597bce013d627025a0c93758d72cc433/05_client-uid-counters/src/libs/utils.js#L8
function uid() {
  let date = (Date.now()).toString();
  const sub = date.substring(date.length-6,date.length-1);
  return sub+"_"+Math.floor(Math.random() * 10000)
}

let id = uid();
---

<div 
  data-unactivated
  class:list={["dropdown", "js-dropdown", { "dropdown-inline js-dropdown-inline": Astro.props.inlineMenu }]}
> 
  <button 
    aria-controls={id} 
    aria-label={Astro.props.label} 
    class="dropdown-toggle js-dropdown-toggle" 
  >
    <slot name="toggle"/>
  </button>
  <div 
    id={id} 
    data-navigation-dropdown-menu-items
    class="dropdown-menu-body z-nav-dropdown" 
  >
    <slot name="items"/>
  </div>
</div>

<style>
  /* hide the menu body */
  .dropdown-menu-body {
    @apply hidden absolute bg-base-200 rounded-b rounded-tr z-dropdown;
  }

  /* No JS */
  /* Note that here we are allowing default menu styles to come through for focus, hover, focus-within */
  [data-unactivated].dropdown:focus-within > .dropdown-toggle:not(:hover, :focus, :focus-within) {
    @apply bg-base-200 rounded;
  }
  
  [data-unactivated].dropdown:focus-within > .dropdown-toggle:focus,
  [data-unactivated].dropdown:focus-within > .dropdown-toggle:focus-within, {
    @apply rounded-b;
  }

  [data-unactivated].dropdown:focus-within > .dropdown-menu-body,
  [data-unactivated].dropdown:hover > .dropdown-menu-body {
    @apply block;
  }

  [data-unactivated].dropdown.dropdown-inline:focus-within > .dropdown-menu-body,
  [data-unactivated].dropdown.dropdown-inline:hover > .dropdown-menu-body {
    @apply static;
  }


  /* With JS */
  .dropdown-toggle[aria-expanded=true] {
    @apply bg-base-200 rounded-b-none;
  }

  .dropdown-toggle[aria-expanded=true] + .dropdown-menu-body {
    @apply block;
  }

  .dropdown-inline .dropdown-toggle[aria-expanded=true] + .dropdown-menu-body {
    @apply static;
  }
</style>

<script>
  for (let navMenu of document.querySelectorAll(".js-dropdown")) {
    let navMenuToggle = navMenu.querySelector(".js-dropdown-toggle") as HTMLElement;
    let navMenuBody = document.getElementById(navMenuToggle.getAttribute('aria-controls')!)!;
    
    // Remove this when there's JS, we use it as a selector to decide whether or not to use the focus/hover expansion
    (navMenu as HTMLElement).removeAttribute('data-unactivated');
    // This doesn't make sense if there's no JS
    navMenuToggle.ariaExpanded = "false";

    navMenuToggle.addEventListener("click", function(e) {
      let target = e.currentTarget as HTMLElement;
      target.ariaExpanded = target.ariaExpanded === "true" ? "false" : "true";
    });

    // If something's displayed inline (mobile view)
    // It looks more like a disclosure since it takes up space. 
    // Given that there is very little current content
    // It seems better to keep the disclosure open
    if (!(navMenu as HTMLElement).matches(".js-dropdown-inline")) {
      navMenuToggle.addEventListener('focusout', function(e) {
        if (!e.relatedTarget || !navMenuBody.contains(e.relatedTarget as HTMLElement)) {
          navMenuToggle.ariaExpanded = "false";
        }
      });
      navMenuBody.addEventListener('focusout', function(e) {
        if (!e.relatedTarget || !navMenuBody.contains(e.relatedTarget as HTMLElement)) {
          navMenuToggle.ariaExpanded = "false";
        }
      });
      let escapeListener = function(e: KeyboardEvent) {
        if (e.key === "Escape") {
          navMenuToggle.ariaExpanded = "false";
          navMenuToggle.focus();
        }
      };
      navMenuToggle.addEventListener("keydown", escapeListener);
      navMenuBody.addEventListener("keydown", escapeListener);
    }
  }
</script>